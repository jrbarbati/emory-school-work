// Do not edit this file for homework.

// A Position is a pair of int coordinates (i, j), which we typically
// use to identify a position in a Maze.  However, there are no
// constraints on i and j here, they can be any integers.

// When we describe the directions up/down/left/right below, we are
// visualizing positions as they occur in a Maze printed as text.
// Then i is the row number (increasing as we go down the page),
// and j is the column number (increasing as we go right).

// See class Maze for some methods that classify Position objects in
// the context of the maze (isValid, isWall, isOpen, adjacent).

public class Position
{
    // Data, just two coordinates:
    public final int i, j;

    // Construct a position object (no constraints on i and j here).
    public Position(int i, int j) { this.i = i; this.j = j; }

    // Convert to String "(i, j)" (overrides the Object method).
    public String toString() { return "("+i+", "+j+")"; }

    // Test for equality (overrides the Object method).
    public boolean equals(Object o) {
        if (!(o instanceof Position)) return false;
        Position p = (Position)o;
        return i==p.i && j==p.j;
    }

    // Given a direction (an int in the range 0 to 7), return
    // the neighbor of this Position, in that direction.
    // The first four directions (0 to 3) are "cardinal":
    // up (decrease i), down, left (decrease j), right.
    // The next four directions (4 to 7) are "diagonal":
    // up-left, up-right, down-left, down-right.
    // Note that the opposite of direction d is (d^1).
    public Position neighbor(int direction)
    {
        switch (direction) {
            // cardinal directions:
        case 0: return new Position(i-1, j  ); // 1 row up
        case 1: return new Position(i+1, j  ); // 1 row down
        case 2: return new Position(i  , j-1); // 1 column left
        case 3: return new Position(i  , j+1); // 1 column right
            // diagonal directions:
        case 4: return new Position(i-1, j-1); // up and left
        case 5: return new Position(i+1, j+1); // down and right
        case 6: return new Position(i-1, j+1); // up and right
        case 7: return new Position(i+1, j-1); // down and left
        }
        throw new RuntimeException("bad direction " + direction);
    }

    // Is p 4-adjacent to this position?  That is, is p one step away
    // in one of the 4 cardinal directions (up, down, left, right)?
    public boolean adjacent4(Position p) {
        int di = Math.abs(i-p.i), dj = Math.abs(j-p.j);
        return di+dj==1;
    }

    // Is p 8-adjacent to this position?  That is, is p one step away
    // in one of the 8 directions (cardinal or diagonal)?
    public boolean adjacent8(Position p) {
        int di = Math.abs(i-p.i), dj = Math.abs(j-p.j);
        return Math.max(di,dj)==1;
    }
}
